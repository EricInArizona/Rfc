RFC 8446 - The Transport Layer Security
(TLS) Protocol Version 1.3

Section 5.
Record Protocol

   The TLS record protocol takes messages to be
 transmitted, fragments
   the data into manageable blocks, protects
 the records, and transmits
   the result.  Received data is verified,
 decrypted, reassembled, and
   then delivered to higher-level clients.

   TLS records are typed, which allows
 multiple higher-level protocols
   to be multiplexed over the same record layer.
  This document
   specifies four content types: handshake,
 application_data, alert, and
   change_cipher_spec.  The change_cipher_spec
 record is used only for
   compatibility purposes (see
 <a href="https://datatracker.ietf.org/doc/html/rfc8446#appendix-D.4">
Appendix D.4</a>).

   An implementation may receive an unencrypted
 record of type
   change_cipher_spec consisting of the
 single byte value 0x01 at any
   time after the first ClientHello message
 has been sent or received
   and before the peer's Finished message has
 been received and MUST
   simply drop it without further processing.
  Note that this record may
   appear at a point at the handshake where the
 implementation is
   expecting protected records, and so it is
 necessary to detect this
   condition prior to attempting to deprotect
 the record.  An
   implementation which receives any other
 change_cipher_spec value or
   which receives a protected change_cipher_spec
 record MUST abort the
   handshake with an "unexpected_message" alert.
  If an implementation
   detects a change_cipher_spec record
 received before the first
   ClientHello message or after the peer's
 Finished message, it MUST be
   treated as an unexpected record type
 (though stateless servers may
   not be able to distinguish these cases from
 allowed cases).

   Implementations MUST NOT send record types
 not defined in this
   document unless negotiated by some extension.
  If a TLS
   implementation receives an unexpected
 record type, it MUST terminate
   the connection with an "unexpected_message"
 alert.  New record
   content type values are assigned by IANA
 in the TLS ContentType
   registry as described in
 <a href="https://datatracker.ietf.org/doc/html/rfc8446#section-11">Section 11</a>.

Section 5.1
Record Layer

   The record layer fragments information
 blocks into TLSPlaintext
   records carrying data in chunks of 2^14
 bytes or less.  Message
   boundaries are handled differently depending
 on the underlying
   ContentType.  Any future content types MUST
 specify appropriate
   rules.  Note that these rules are stricter
 than what was enforced in
   TLS 1.2.

   Handshake messages MAY be coalesced into a
 single TLSPlaintext record
   or fragmented across several records, provided
 that:

   -  Handshake messages MUST NOT be interleaved
 with other record
      types.  That is, if a handshake message
 is split over two or more
      records, there MUST NOT be any other
 records between them.

   -  Handshake messages MUST NOT span key
 changes.  Implementations
      MUST verify that all messages immediately
 preceding a key change
      align with a record boundary; if not,
 then they MUST terminate the
      connection with an "unexpected_message"
 alert.  Because the
      ClientHello, EndOfEarlyData, ServerHello,
 Finished, and KeyUpdate
      messages can immediately precede a
 key change, implementations
      MUST send these messages in alignment
 with a record boundary.

   Implementations MUST NOT send zero-length
 fragments of Handshake
   types, even if those fragments contain
padding.

   Alert messages
(<a href="https://datatracker.ietf.org/doc/html/rfc8446#section-6">
Section 6</a>)
 MUST NOT be fragmented across records, and
 multiple alert messages MUST NOT be coalesced
 into a single
   TLSPlaintext record.  In other words, a
 record with an Alert type
   MUST contain exactly one message.

   Application Data messages contain data that
 is opaque to TLS.
   Application Data messages are always
 protected.  Zero-length
   fragments of Application Data MAY be sent,
 as they are potentially
   useful as a traffic analysis countermeasure.
  Application Data
   fragments MAY be split across multiple
 records or coalesced into a
   single record.


      enum {
          invalid(0),
          change_cipher_spec(20),
          alert(21),
          handshake(22),
          application_data(23),
          (255)
      } ContentType;

      struct {
          ContentType type;
          ProtocolVersion legacy_record_version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;

   type:  The higher-level protocol used to
 process the enclosed
      fragment.

   legacy_record_version:  MUST be set to
 0x0303 for all records
      generated by a TLS 1.3 implementation
 other than an initial
      ClientHello (i.e., one not generated
after a HelloRetryRequest),
      where it MAY also be 0x0301 for
 compatibility purposes.  This
      field is deprecated and MUST be
 ignored for all purposes.
      Previous versions of TLS would use
 other values in this field
      under some circumstances.

   length:  The length (in bytes) of the following
      TLSPlaintext.fragment.  The length
 MUST NOT exceed 2^14 bytes.  An
      endpoint that receives a record that
 exceeds this length MUST
      terminate the connection with a
 "record_overflow" alert.

   fragment:  The data being transmitted.
 This value is transparent and
      is treated as an independent block to
 be dealt with by the higher-
      level protocol specified by the type field.

   This document describes TLS 1.3, which uses
 the version 0x0304.  This
   version value is historical, deriving from
 the use of 0x0301 for
   TLS 1.0 and 0x0300 for SSL 3.0.  In order
 to maximize backward
   compatibility, a record containing an
 initial ClientHello SHOULD have
   version 0x0301 (reflecting TLS 1.0) and a
 record containing a second
   ClientHello or a ServerHello MUST have
 version 0x0303 (reflecting
   TLS 1.2).  When negotiating prior versions
 of TLS, endpoints follow
   the procedure and requirements provided in
 <a href="https://datatracker.ietf.org/doc/html/rfc8446#appendix-D">
Appendix D</a>.



   When record protection has not yet been
 engaged, TLSPlaintext
   structures are written directly onto the
 wire.  Once record
   protection has started, TLSPlaintext
 records are protected and sent
   as described in the following section.
  Note that Application Data
   records MUST NOT be written to the wire
 unprotected (see
 <a href="https://datatracker.ietf.org/doc/html/rfc8446#section-2">
Section 2</a>
   for details).

section-5.2
Record Payload Protection

   The record protection functions translate
 a TLSPlaintext structure
   into a TLSCiphertext structure.  The
 deprotection functions reverse
   the process.  In TLS 1.3, as opposed to
 previous versions of TLS, all
   ciphers are modeled as "Authenticated
Encryption with Associated
   Data" (AEAD)
[<a href="https://datatracker.ietf.org/doc/html/rfc5116" title="&quot;An Interface and Algorithms for Authenticated Encryption&quot;">RFC5116</a>].
  AEAD functions provide a unified encryption
   and authentication operation which turns
 plaintext into authenticated
   ciphertext and back again.  Each encrypted
record consists of a
   plaintext header followed by an encrypted
body, which itself contains
   a type and optional padding.

      struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
      } TLSInnerPlaintext;

      struct {
          ContentType opaque_type = application_data; /* 23 */
          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
          uint16 length;
          opaque encrypted_record[TLSCiphertext.length];
      } TLSCiphertext;

   content:  The TLSPlaintext.fragment value,
 containing the byte
      encoding of a handshake or an alert
 message, or the raw bytes of
      the application's data to send.

   type:  The TLSPlaintext.type value
 containing the content type of the
      record.

   zeros:  An arbitrary-length run of
zero-valued bytes may appear in
      the cleartext after the type field.
  This provides an opportunity
      for senders to pad any TLS record by a
 chosen amount as long as
      the total stays within record size
 limits.  See
 <a href="https://datatracker.ietf.org/doc/html/rfc8446#section-5.4">
Section 5.4</a> for
      more details.


   opaque_type:  The outer opaque_type field
 of a TLSCiphertext record
      is always set to the value 23
 (application_data) for outward
      compatibility with middleboxes accustomed
 to parsing previous
      versions of TLS.  The actual content type
 of the record is found
      in TLSInnerPlaintext.type after decryption.

   legacy_record_version:  The
legacy_record_version field is always
      0x0303.  TLS 1.3 TLSCiphertexts are not
 generated until after
      TLS 1.3 has been negotiated, so there
 are no historical
      compatibility concerns where other
 values might be received.  Note
      that the handshake protocol, including
 the ClientHello and
      ServerHello messages, authenticates
the protocol version, so this
      value is redundant.

   length:  The length (in bytes) of
 the following
      TLSCiphertext.encrypted_record, which
 is the sum of the lengths of
      the content and the padding, plus one
 for the inner content type,
      plus any expansion added by the AEAD
 algorithm.  The length
      MUST NOT exceed 2^14 + 256 bytes.  An
 endpoint that receives a
      record that exceeds this length MUST
 terminate the connection with
      a "record_overflow" alert.

   encrypted_record:  The AEAD-encrypted form
 of the serialized
      TLSInnerPlaintext structure.

   AEAD algorithms take as input a single key,
 a nonce, a plaintext, and
   "additional data" to be included in the
 authentication check, as
   described in
 <a href="https://datatracker.ietf.org/doc/html/rfc5116#section-2.1">
Section&nbsp;2.1 of [RFC5116]</a>.
  The key is either the
   client_write_key or the server_write_key,
 the nonce is derived from
   the sequence number and the client_write_iv
 or server_write_iv (see
   <a href="https://datatracker.ietf.org/doc/html/rfc8446#section-5.3">
Section 5.3</a>),
 and the additional data input is the
 record header.

   I.e.,

      additional_data =
             TLSCiphertext.opaque_type ||
             TLSCiphertext.legacy_record_version ||
             TLSCiphertext.length

   The plaintext input to the AEAD algorithm
 is the encoded
   TLSInnerPlaintext structure.  Derivation
 of traffic keys is defined
   in
<a href="https://datatracker.ietf.org/doc/html/rfc8446#section-7.3">
Section 7.3</a>.

   The AEAD output consists of the ciphertext
 output from the AEAD
   encryption operation.  The length of the
 plaintext is greater than
   the corresponding TLSPlaintext.length due
 to the inclusion of
   TLSInnerPlaintext.type and any padding
supplied by the sender.  The
   length of the AEAD output will generally
 be larger than the
   plaintext, but by an amount that varies
 with the AEAD algorithm.


   Since the ciphers might incorporate padding,
 the amount of overhead
   could vary with different lengths of
 plaintext.  Symbolically,

      AEADEncrypted =
          AEAD-Encrypt(write_key,
             nonce, additional_data, plaintext)

   The encrypted_record field of TLSCiphertext
 is set to AEADEncrypted.

   In order to decrypt and verify, the cipher
 takes as input the key,
   nonce, additional data, and the AEADEncrypted
 value.  The output is
   either the plaintext or an error
 indicating that the decryption
   failed.  There is no separate integrity
check.  Symbolically,

      plaintext of encrypted_record =
          AEAD-Decrypt(peer_write_key, nonce,
                 additional_data, AEADEncrypted)

   If the decryption fails, the receiver
 MUST terminate the connection
   with a "bad_record_mac" alert.

   An AEAD algorithm used in TLS 1.3 MUST NOT
 produce an expansion
   greater than 255 octets.  An endpoint that
 receives a record from its
   peer with TLSCiphertext.length larger than
 2^14 + 256 octets MUST
   terminate the connection with a
 "record_overflow" alert.  This limit
   is derived from the maximum TLSInnerPlaintext
 length of 2^14 octets +
   1 octet for ContentType + the maximum AEAD
 expansion of 255 octets.

section-5.3
Per-Record Nonce

   A 64-bit sequence number is maintained
 separately for reading and
   writing records.  The appropriate sequence
 number is incremented by
   one after reading or writing each record.
  Each sequence number is
   set to zero at the beginning of a connection
 and whenever the key is
   changed; the first record transmitted
 under a particular traffic key
   MUST use sequence number 0.

   Because the size of sequence numbers is
 64-bit, they should not wrap.
   If a TLS implementation would need to wrap
 a sequence number, it MUST
   either rekey
(<a href="https://datatracker.ietf.org/doc/html/rfc8446#section-4.6.3">
Section 4.6.3</a>)
 or terminate the connection.


   Each AEAD algorithm will specify a range
 of possible lengths for the
   per-record nonce, from N_MIN bytes to
 N_MAX bytes of input
[<a href="https://datatracker.ietf.org/doc/html/rfc5116" title="&quot;
An Interface and Algorithms for Authenticated
 Encryption&quot;">RFC5116</a>].
   The length of the TLS per-record nonce
 (iv_length) is set to the
   larger of 8 bytes and N_MIN for the AEAD
 algorithm (see
<a href="https://datatracker.ietf.org/doc/html/rfc5116#section-4">
[RFC5116],
   Section&nbsp;4</a>).
  An AEAD algorithm where N_MAX is less than
 8 bytes
   MUST NOT be used with TLS.  The per-record
 nonce for the AEAD
   construction is formed as follows:

   1.  The 64-bit record sequence number is
 encoded in network byte
       order and padded to the left with
 zeros to iv_length.

   2.  The padded sequence number is XORed
 with either the static
       client_write_iv or server_write_iv
(depending on the role).

   The resulting quantity (of length iv_length)
 is used as the
   per-record nonce.

   Note: This is a different construction
 from that in TLS 1.2, which
   specified a partially explicit nonce.


section-5.4
Record Padding

   All encrypted TLS records can be padded
 to inflate the size of the
   TLSCiphertext.  This allows the sender to
 hide the size of the
   traffic from an observer.

   When generating a TLSCiphertext record,
 implementations MAY choose to
   pad.  An unpadded record is just a record
with a padding length of
   zero.  Padding is a string of zero-valued
 bytes appended to the
   ContentType field before encryption.
  Implementations MUST set the
   padding octets to all zeros before encrypting.

   Application Data records may contain a
 zero-length
   TLSInnerPlaintext.content if the sender
 desires.  This permits
   generation of plausibly sized cover traffic
 in contexts where the
   presence or absence of activity may be
 sensitive.  Implementations
   MUST NOT send Handshake and Alert records
 that have a zero-length
   TLSInnerPlaintext.content; if such a
 message is received, the
   receiving implementation MUST terminate
 the connection with an
   "unexpected_message" alert.


   The padding sent is automatically verified
 by the record protection
   mechanism; upon successful decryption of a
   TLSCiphertext.encrypted_record, the
 receiving implementation scans
   the field from the end toward the beginning
 until it finds a non-zero
   octet.  This non-zero octet is the content
 type of the message.  This
   padding scheme was selected because it
 allows padding of any
   encrypted TLS record by an arbitrary size
 (from zero up to TLS record
   size limits) without introducing new content
 types.  The design also
   enforces all-zero padding octets, which
 allows for quick detection of
   padding errors.

   Implementations MUST limit their scanning
 to the cleartext returned
   from the AEAD decryption.  If a receiving
 implementation does not
   find a non-zero octet in the cleartext,
 it MUST terminate the
   connection with an "unexpected_message" alert.

   The presence of padding does not change the
 overall record size
   limitations: the full encoded
 TLSInnerPlaintext MUST NOT exceed 2^14
   + 1 octets.  If the maximum fragment length
 is reduced -- as, for
   example, by the record_size_limit extension
 from
[<a href="https://datatracker.ietf.org/doc/html/rfc8449"
 title="&quot;Record Size Limit Extension for
 TLS&quot;">RFC8449</a>]
 -- then
   the reduced limit applies to the full
 plaintext, including the
   content type and padding.

   Selecting a padding policy that suggests
 when and how much to pad is
   a complex topic and is beyond the scope
 of this specification.  If
   the application-layer protocol on top of
 TLS has its own padding, it
   may be preferable to pad Application Data
 TLS records within the
   application layer.  Padding for encrypted
 Handshake or Alert records
   must still be handled at the TLS layer,
 though.  Later documents may
   define padding selection algorithms or
define a padding policy
   request mechanism through TLS extensions
 or some other means.


section-5.5
Limits on Key Usage

There are cryptographic limits on the amount
 of plaintext which can
   be safely encrypted under a given set of
 keys.
[<a href="https://datatracker.ietf.org/doc/html/rfc8446#ref-AEAD-LIMITS">
AEAD-LIMITS</a>]
   provides an analysis of these limits under
 the assumption that the
   underlying primitive (AES or ChaCha20)
has no weaknesses.
   Implementations SHOULD do a key update
 as described in
<a href="https://datatracker.ietf.org/doc/html/rfc8446#section-4.6.3">
Section 4.6.3</a>
   prior to reaching these limits.

   For AES-GCM, up to 2^24.5 full-size
 records (about 24 million) may be
   encrypted on a given connection while
 keeping a safety margin of
   approximately 2^-57 for Authenticated
 Encryption (AE) security.  For
   ChaCha20/Poly1305, the record sequence
 number would wrap before the
   safety limit is reached.
